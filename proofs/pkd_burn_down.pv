(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#burndown *)
(*# BurnDown: Instance operator privilege to delete actor's keys and auxiliary data *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#burndown-validation-steps *)
(*# BurnDown MUST atomically revoke all public keys AND auxiliary data for the Actor. *)

(* TYPE DECLARATIONS *)

type actor_id.                 (* Actor identifier *)
type server_id.                (* Server/instance identifier *)
type public_key.               (* Ed25519 public key *)
type secret_key.               (* Ed25519 secret key *)
type signature.                (* Ed25519 signature *)
type message.                  (* Protocol messages *)
type totp_code.                (* TOTP 8-digit code *)
type totp_key.                 (* 256-bit TOTP shared secret *)
type time_window.              (* 30-second time window *)
type aux_type.                 (* Auxiliary data extension type *)
type aux_id.                   (* Auxiliary data identifier *)
type aux_data.                 (* Auxiliary data content *)

(* CHANNELS *)

free c: channel.               (* Public network channel *)
free pkd_internal: channel [private].  (* Internal PKD state *)
(* Spec: BurnDown is NOT HPKE-encrypted; uses
   separate operator API *)
free burndown_api: channel.    (* Operator-facing API *)

(* CRYPTOGRAPHIC FUNCTIONS *)

(* --- Ed25519 Signatures --- *)
fun pk(secret_key): public_key.
fun sign(message, secret_key): signature.
reduc forall m: message, sk: secret_key;
  verify_sig(m, sign(m, sk), pk(sk)) = true.

(* --- Message Construction --- *)
fun BurnDownMsg(actor_id): message.
fun FireproofMsg(actor_id): message.
fun UndoFireproofMsg(actor_id): message.

(* --- TOTP (spec: SHA-512, 8 digits, 30s window) --- *)
fun totp_generate(totp_key, time_window): totp_code.
reduc forall s: totp_key, tw: time_window;
  totp_verify(totp_generate(s, tw), s, tw) = true.

fun prev_window(time_window): time_window.

(* TABLES FOR STATE TRACKING *)

table registered_keys(actor_id, public_key).
table fireproof_actors(actor_id).
table totp_secrets(server_id, totp_key).
table actor_servers(actor_id, server_id).
table auxiliary_data(actor_id, aux_type, aux_id, aux_data).
table revoked_aux_data(actor_id, aux_id).

(* EVENTS FOR SECURITY PROPERTIES *)

event BurnDownAccepted(actor_id).
event BurnDownRejected(actor_id).
event FireproofSet(actor_id).
event UndoFireproofSet(actor_id).
event TOTPVerified(server_id, totp_code).
event TOTPEnrolled(server_id, totp_key).
event SignedByActor(actor_id, secret_key).
event SignedByOperator(server_id, actor_id).
event AllKeysDeleted(actor_id).
event AllAuxDataRevoked(actor_id).
event ActorHasKeys(actor_id).
event ActorHasAuxData(actor_id, aux_id).

(* SECURITY QUERIES *)

(* --- Query 1: BurnDown Requires Operator Signature ---
   BurnDown must be signed by operator, not actor themselves *)
query actor: actor_id, server: server_id;
  event(BurnDownAccepted(actor)) ==>
    event(SignedByOperator(server, actor)).

(* --- Query 2: BurnDown Revokes Auxiliary Data ---
   When BurnDown is accepted, all auxiliary data must also be revoked.
   This models the spec's atomicity requirement: keys AND aux data. *)
query actor: actor_id;
  event(BurnDownAccepted(actor)) ==>
    event(AllAuxDataRevoked(actor)).

(* --- Query 3: TOTP Required When Configured ---
   If TOTP is enrolled and BurnDown accepted, TOTP was verified *)
query server: server_id, tkey: totp_key,
      code: totp_code, actor: actor_id;
  (event(TOTPEnrolled(server, tkey)) &&
   event(BurnDownAccepted(actor))) ==>
    event(TOTPVerified(server, code)).

(* --- Query 4: Actor Cannot Self-BurnDown ---
   Actor's signature should not directly cause BurnDown *)
free honest_actor: actor_id.
free honest_actor_sk: secret_key [private].
query event(BurnDownAccepted(honest_actor)) && event(SignedByActor(honest_actor, honest_actor_sk)).

(* PKD BURNDOWN PROCESSING *)

(* Spec: BurnDown is NOT HPKE-encrypted; arrives via
   operator API, not the normal protocol message channel *)
let PKD_ProcessBurnDown =
  in(burndown_api, (actor: actor_id, server: server_id,
    sig: signature, server_pk: public_key,
    totp_opt: totp_code, tw: time_window));

  let msg = BurnDownMsg(actor) in

  (* REQUIREMENT 1: Verify signature from instance operator *)
  if verify_sig(msg, sig, server_pk) = true then
  event SignedByOperator(server, actor);

  (* Check that server matches actor's server *)
  get actor_servers(=actor, =server) in

  (* REQUIREMENT 2: Check if actor is Fireproof *)
  get fireproof_actors(=actor) in
    (* Actor is Fireproof - reject BurnDown *)
    event BurnDownRejected(actor);
    0
  else
    (* Not Fireproof, check TOTP if enrolled *)
    get totp_secrets(=server, tkey) in
      (* TOTP enrolled — actually verify the code *)
      event TOTPEnrolled(server, tkey);

      (* Try current window *)
      if totp_verify(totp_opt, tkey, tw) = true then
        event TOTPVerified(server, totp_opt);

        (* REQUIREMENT 3: Atomically revoke keys+aux *)
        event AllKeysDeleted(actor);
        get auxiliary_data(=actor, atype, aid, adata) in
          insert revoked_aux_data(actor, aid);
          event AllAuxDataRevoked(actor);
          event BurnDownAccepted(actor);
          out(c, (actor, server))
        else
          event AllAuxDataRevoked(actor);
          event BurnDownAccepted(actor);
          out(c, (actor, server))
      else
        (* Try t-1 window *)
        let tw1 = prev_window(tw) in
        if totp_verify(totp_opt, tkey, tw1) = true then
          event TOTPVerified(server, totp_opt);

          event AllKeysDeleted(actor);
          get auxiliary_data(=actor, atype, aid, adata) in
            insert revoked_aux_data(actor, aid);
            event AllAuxDataRevoked(actor);
            event BurnDownAccepted(actor);
            out(c, (actor, server))
          else
            event AllAuxDataRevoked(actor);
            event BurnDownAccepted(actor);
            out(c, (actor, server))
        else
          (* Try t-2 per RFC 6238 §5.2 *)
          let tw2 = prev_window(tw1) in
          if totp_verify(totp_opt, tkey, tw2) = true then
            event TOTPVerified(server, totp_opt);

            event AllKeysDeleted(actor);
            get auxiliary_data(=actor, atype, aid, adata) in
              insert revoked_aux_data(actor, aid);
              event AllAuxDataRevoked(actor);
              event BurnDownAccepted(actor);
              out(c, (actor, server))
            else
              event AllAuxDataRevoked(actor);
              event BurnDownAccepted(actor);
              out(c, (actor, server))
          else
            0  (* TOTP verification failed *)
    else
      (* TOTP not enrolled, proceed with BurnDown *)
      event AllKeysDeleted(actor);
      get auxiliary_data(=actor, atype, aid, adata) in
        insert revoked_aux_data(actor, aid);
        event AllAuxDataRevoked(actor);
        event BurnDownAccepted(actor);
        out(c, (actor, server))
      else
        event AllAuxDataRevoked(actor);
        event BurnDownAccepted(actor);
        out(c, (actor, server))
  else
    0  (* Server mismatch *)
  else
    0. (* Signature verification failed *)

(* PKD FIREPROOF PROCESSING *)

let PKD_ProcessFireproof =
  in(c, (actor: actor_id, sig: signature, actor_pk: public_key));

  let msg = FireproofMsg(actor) in

  (* Verify signature from actor *)
  if verify_sig(msg, sig, actor_pk) = true then

  (* Check actor has this key registered *)
  get registered_keys(=actor, =actor_pk) in
    (* Set Fireproof status *)
    insert fireproof_actors(actor);
    event FireproofSet(actor);
    out(c, actor).

let PKD_ProcessUndoFireproof =
  in(c, (actor: actor_id, sig: signature, actor_pk: public_key));

  let msg = UndoFireproofMsg(actor) in

  (* Verify signature from actor *)
  if verify_sig(msg, sig, actor_pk) = true then

  (* Check actor has this key registered *)
  get registered_keys(=actor, =actor_pk) in
    (* Remove Fireproof status (in real implementation, delete from table) *)
    event UndoFireproofSet(actor);
    out(c, actor).

(* HONEST SCENARIOS *)

(* Honest actor sets Fireproof and has auxiliary data *)
let HonestActorSetFireproof(actor: actor_id, actor_sk: secret_key,
                             atype: aux_type, aid: aux_id,
                             adata: aux_data) =
  let actor_pk = pk(actor_sk) in
  insert registered_keys(actor, actor_pk);
  event ActorHasKeys(actor);

  (* Actor has auxiliary data *)
  insert auxiliary_data(actor, atype, aid, adata);
  event ActorHasAuxData(actor, aid);

  (* Sign Fireproof message *)
  let msg = FireproofMsg(actor) in
  let sig = sign(msg, actor_sk) in

  event SignedByActor(actor, actor_sk);
  out(c, (actor, sig, actor_pk)).

(* Instance operator issues BurnDown via operator API *)
let OperatorBurnDown(
  actor: actor_id, server: server_id,
  operator_sk: secret_key, tkey: totp_key
) =
  let operator_pk = pk(operator_sk) in
  insert actor_servers(actor, server);
  insert totp_secrets(server, tkey);
  event TOTPEnrolled(server, tkey);

  (* Sign BurnDown message *)
  let msg = BurnDownMsg(actor) in
  let sig = sign(msg, operator_sk) in

  (* Generate real TOTP code *)
  new tw: time_window;
  let totp = totp_generate(tkey, tw) in

  (* BurnDown goes via operator API, not HPKE channel *)
  out(burndown_api,
    (actor, server, sig, operator_pk, totp, tw)).

(* ATTACKER SCENARIOS *)

(* Actor tries to burn down their own account *)
let ActorSelfBurnDown(
  actor: actor_id, server: server_id,
  actor_sk: secret_key
) =
  let actor_pk = pk(actor_sk) in
  insert registered_keys(actor, actor_pk);
  insert actor_servers(actor, server);

  (* Actor signs BurnDown message themselves *)
  let msg = BurnDownMsg(actor) in
  let sig = sign(msg, actor_sk) in

  event SignedByActor(actor, actor_sk);

  (* Attacker generates fake TOTP with unknown key *)
  new fake_tkey: totp_key;
  new tw: time_window;
  let totp = totp_generate(fake_tkey, tw) in

  out(burndown_api,
    (actor, server, sig, actor_pk, totp, tw)).

(* Attacker tries to burn down Fireproof actor *)
let AttackerBurnDownFireproof(
  actor: actor_id, server: server_id,
  operator_sk: secret_key, actor_sk: secret_key
) =
  let actor_pk = pk(actor_sk) in
  let operator_pk = pk(operator_sk) in

  (* Actor is Fireproof *)
  insert registered_keys(actor, actor_pk);
  insert fireproof_actors(actor);
  insert actor_servers(actor, server);
  event FireproofSet(actor);

  (* Operator tries to BurnDown *)
  let msg = BurnDownMsg(actor) in
  let sig = sign(msg, operator_sk) in

  new fake_tkey: totp_key;
  new tw: time_window;
  let totp = totp_generate(fake_tkey, tw) in

  out(burndown_api,
    (actor, server, sig, operator_pk, totp, tw)).

(* MAIN PROCESS *)

process
  (* Create honest actor *)
  new honest_actor_id: actor_id;
  new honest_sk: secret_key;
  new honest_server: server_id;

  (* Create operator *)
  new operator_server: server_id;
  new operator_sk: secret_key;
  new operator_totp_key: totp_key;

  (* Create attacker *)
  new attacker_actor: actor_id;
  new attacker_sk: secret_key;
  new attacker_server: server_id;

  (* Auxiliary data for honest actor *)
  new honest_aux_type: aux_type;
  new honest_aux_id: aux_id;
  new honest_aux_data: aux_data;

  (* Aux data for BurnDown target *)
  new target_aux_type: aux_type;
  new target_aux_id: aux_id;
  new target_aux_data: aux_data;
  insert auxiliary_data(honest_actor_id, target_aux_type,
                        target_aux_id, target_aux_data);

  out(c, honest_actor_id);
  out(c, attacker_actor);
  out(c, attacker_sk);
  out(c, attacker_server);

  (
    (* PKD processes *)
    !PKD_ProcessBurnDown |
    !PKD_ProcessFireproof |
    !PKD_ProcessUndoFireproof |

    (* Honest scenarios *)
    HonestActorSetFireproof(honest_actor, honest_sk,
                             honest_aux_type, honest_aux_id,
                             honest_aux_data) |
    OperatorBurnDown(honest_actor_id, honest_server,
                     operator_sk, operator_totp_key) |

    (* Attacker scenarios *)
    !ActorSelfBurnDown(attacker_actor, attacker_server,
                        attacker_sk) |
    !AttackerBurnDownFireproof(honest_actor, honest_server,
                                operator_sk, honest_sk)
  )
