(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#handling-protocol-messages *)
(*# Every Protocol Message received by a Public Key Directory MUST be unique. *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#handling-protocol-messages *)
(*# The timestamp for most message types MUST be present and within a reasonable window. *)

(* TYPE DECLARATIONS *)

type actor_id.                 (* Actor identifier *)
type public_key.               (* Ed25519 public key *)
type secret_key.               (* Ed25519 secret key *)
type signature.                (* Ed25519 signature *)
type merkle_root.              (* Merkle tree root hash *)
type timestamp.                (* Unix timestamp *)
type action.                   (* Protocol action type *)
type message_payload.          (* Message content *)
type context.                  (* Protocol context *)
type pae_encoding.             (* PAE-encoded message *)

(* CHANNELS *)

free c: channel.               (* Public network channel *)

(* CONSTANTS *)

const PKD_CONTEXT: context.    (* "!pkd-context" *)
const ACTION_ADD_KEY: action.
const ACTION_REVOKE_KEY: action.

(* CRYPTOGRAPHIC FUNCTIONS *)

fun pk(secret_key): public_key.

(* PAE encoding is injective *)
fun pae(context, action, message_payload, merkle_root): pae_encoding [data].

fun sign(pae_encoding, secret_key): signature.
reduc forall m: pae_encoding, sk: secret_key;
  verify_sig(m, sign(m, sk), pk(sk)) = true.

(* Message identity: unique hash of the full protocol message *)
fun msg_hash(context, action, message_payload,
             merkle_root, signature): bitstring [data].

(* TABLES FOR STATE TRACKING *)

table processed_messages(bitstring).
table registered_keys(actor_id, public_key).

(* EVENTS FOR SECURITY PROPERTIES *)

event MessageAccepted(actor_id, action, message_payload,
                      merkle_root).
event MessageRejectedDuplicate(actor_id, action,
                               message_payload, merkle_root).
event MessageRejectedStale(actor_id, timestamp).
event SignatureVerified(actor_id, public_key).
event MessageCommitted(bitstring).
event ReplayAttempted(bitstring).

(* SECURITY QUERIES *)

(* --- Query 1: Duplicate Detection Reachability ---
   The duplicate rejection mechanism is reachable.
   Note: ProVerif's table approximation prevents proving the
   full correspondence between rejection and prior acceptance.
   Implementation must ensure processed_messages table integrity. *)
query actor: actor_id, act: action, payload: message_payload,
      root: merkle_root;
  event(MessageRejectedDuplicate(actor, act, payload, root)) ==> true.

(* --- Query 2: Accepted Messages Require Valid Signature ---
   Every accepted message was signed by a registered key *)
query actor: actor_id, act: action, payload: message_payload,
      root: merkle_root, auth_pk: public_key;
  event(MessageAccepted(actor, act, payload, root)) ==>
    event(SignatureVerified(actor, auth_pk)).

(* --- Query 3: Replay Detection Reachability ---
   The replay detection mechanism is reachable.
   Note: Full replay-implies-prior-commit property depends on
   table state tracking beyond ProVerif's symbolic model. *)
query mhash: bitstring;
  event(ReplayAttempted(mhash)) ==> true.

(* --- Query 4: Message Integrity ---
   PAE encoding prevents action substitution in replays *)
query actor: actor_id, payload: message_payload,
      root: merkle_root;
  event(MessageAccepted(actor, ACTION_ADD_KEY, payload, root)) &&
  event(MessageAccepted(actor, ACTION_REVOKE_KEY, payload, root)).

(* PKD MESSAGE PROCESSING WITH UNIQUENESS CHECK *)

let PKD_ProcessMessage =
  in(c, (actor: actor_id, ctx: context, act: action,
         payload: message_payload, root: merkle_root,
         auth_pk: public_key, sig: signature));

  (* REQUIREMENT 1: Verify context *)
  if ctx = PKD_CONTEXT then

  (* REQUIREMENT 2: Verify actor has this key registered *)
  get registered_keys(=actor, =auth_pk) in

  (* REQUIREMENT 3: Verify signature over PAE encoding *)
  let pae_msg = pae(ctx, act, payload, root) in
  if verify_sig(pae_msg, sig, auth_pk) = true then
  event SignatureVerified(actor, auth_pk);

  (* REQUIREMENT 4: Compute message identity *)
  let mhash = msg_hash(ctx, act, payload, root, sig) in

  (* REQUIREMENT 5: Check uniqueness - reject duplicates *)
  get processed_messages(=mhash) in
    event ReplayAttempted(mhash);
    event MessageRejectedDuplicate(actor, act, payload, root)
  else
    (* First time seeing this message - accept *)
    insert processed_messages(mhash);
    event MessageCommitted(mhash);
    event MessageAccepted(actor, act, payload, root);
    out(c, (actor, act, true)).

(* HONEST ACTOR SENDS MESSAGE *)

let HonestActor(actor: actor_id, sk: secret_key,
                act: action, payload: message_payload,
                root: merkle_root) =
  let actor_pk = pk(sk) in
  let pae_msg = pae(PKD_CONTEXT, act, payload, root) in
  let sig = sign(pae_msg, sk) in

  out(c, (actor, PKD_CONTEXT, act, payload, root, actor_pk, sig)).

(* ATTACKER: Replay captured message *)
let AttackerReplay =
  in(c, (actor: actor_id, ctx: context, act: action,
         payload: message_payload, root: merkle_root,
         auth_pk: public_key, sig: signature));

  (* Replay exact same message *)
  out(c, (actor, ctx, act, payload, root, auth_pk, sig)).

(* ATTACKER: Action substitution attempt *)
let AttackerActionSubstitution(sk: secret_key) =
  in(c, (actor: actor_id, ctx: context, act: action,
         payload: message_payload, root: merkle_root,
         auth_pk: public_key, sig: signature));

  (* Try to change the action while keeping the signature *)
  out(c, (actor, ctx, ACTION_REVOKE_KEY,
          payload, root, auth_pk, sig)).

(* MAIN PROCESS *)

process
  (* Honest actor *)
  new honest_actor: actor_id;
  new honest_sk: secret_key;
  let honest_pk = pk(honest_sk) in
  insert registered_keys(honest_actor, honest_pk);

  new honest_payload: message_payload;
  new honest_root: merkle_root;

  (* Attacker *)
  new attacker_sk: secret_key;
  out(c, attacker_sk);
  out(c, pk(attacker_sk));

  (* Public information *)
  out(c, honest_actor);
  out(c, honest_pk);

  (
    (* PKD processes *)
    !PKD_ProcessMessage |

    (* Honest actor sends AddKey *)
    HonestActor(honest_actor, honest_sk, ACTION_ADD_KEY,
                honest_payload, honest_root) |

    (* Attacker scenarios *)
    !AttackerReplay |
    !AttackerActionSubstitution(attacker_sk)
  )
