(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#revokekey *)
(*# Attempting to issue a `RevokeKey` **MUST** fail unless there is another public key associated with this Actor. *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#revokekey *)
(*# **Protocol Invariant**: Implementations **MUST** enforce that at least one valid (non-revoked) public key remains *)
(*# after a `RevokeKey` operation. *)

(* TYPE DECLARATIONS *)

type actor_id.                 (* Actor identifier *)
type public_key.               (* Ed25519 public key *)
type secret_key.               (* Ed25519 secret key *)
type signature.                (* Ed25519 signature *)
type message.                  (* Protocol messages *)

(* CHANNELS *)

free c: channel.               (* Public network channel *)

(* CRYPTOGRAPHIC FUNCTIONS *)

fun pk(secret_key): public_key.
fun sign(message, secret_key): signature.
reduc forall m: message, sk: secret_key;
  verify(m, sign(m, sk), pk(sk)) = true.

fun RevokeKeyMsg(actor_id, public_key): message.

(* TABLES FOR STATE TRACKING *)

(* Track registered keys with count *)
table registered_keys(actor_id, public_key).
table revoked_keys(actor_id, public_key).

(* EVENTS FOR SECURITY PROPERTIES *)

event KeyRevoked(actor_id, public_key).
event RevocationAuthorized(actor_id, public_key, public_key). (* actor, revoked_key, auth_key *)
event LastKeyRevocationAttempt(actor_id, public_key).
event LastKeyRevocationBlocked(actor_id, public_key).
event ActorHasMultipleKeys(actor_id).
event ActorHasSingleKey(actor_id).
event SelfRevocationAttempt(actor_id, public_key).
event SelfRevocationBlocked(actor_id, public_key).

(* SECURITY QUERIES *)

(* --- Query 1: Last Key Revocation is Blocked ---
   When last key revocation attempt is made and blocked, both events fire *)
query actor: actor_id, revoke_pk: public_key;
  event(LastKeyRevocationBlocked(actor, revoke_pk)) ==>
    event(LastKeyRevocationAttempt(actor, revoke_pk)).

(* --- Query 2: Self-Revocation is Blocked ---
   When self-revocation attempt is made and blocked, both events fire *)
query actor: actor_id, revoke_pk: public_key;
  event(SelfRevocationBlocked(actor, revoke_pk)) ==>
    event(SelfRevocationAttempt(actor, revoke_pk)).

(* --- Query 3: Successful Revocation Implies Multiple Keys ---
   If a key was successfully revoked, actor must have had multiple keys *)
query actor: actor_id, revoke_pk: public_key;
  event(KeyRevoked(actor, revoke_pk)) ==>
    event(ActorHasMultipleKeys(actor)).

(* --- Query 4: Revocation Authorization ---
   Any revoked key must have been authorized by a different valid key *)
query actor: actor_id, revoke_pk: public_key, auth_pk: public_key;
  event(KeyRevoked(actor, revoke_pk)) ==>
    event(RevocationAuthorized(actor, revoke_pk, auth_pk)).

(* --- Query 5: Cannot Revoke with Revoked Key ---
   A revoked key cannot authorize further revocations *)
query actor: actor_id, revoke_pk: public_key, auth_pk: public_key;
  event(KeyRevoked(actor, revoke_pk)) ==>
    (auth_pk <> revoke_pk).

(* PKD REVOKEKEY PROCESSING WITH INVARIANT ENFORCEMENT
   Unified N-key process using dynamic table lookups *)

let PKD_ProcessRevokeKey =
  in(c, (actor: actor_id, revoke_pk: public_key,
         auth_pk: public_key, sig: signature));

  let msg = RevokeKeyMsg(actor, revoke_pk) in

  (* Check: key to revoke must be registered *)
  get registered_keys(=actor, =revoke_pk) in

  (* Check: Cannot revoke with the same key *)
  if auth_pk = revoke_pk then
  (
    event SelfRevocationAttempt(actor, revoke_pk);
    event SelfRevocationBlocked(actor, revoke_pk)
  )
  else
  (
    (* Check: auth_pk must be registered *)
    get registered_keys(=actor, =auth_pk) in

    (* Check: auth_pk must not be revoked *)
    get revoked_keys(=actor, =auth_pk) in
      0  (* Auth key already revoked *)
    else

    (* Verify signature *)
    if verify(msg, sig, auth_pk) = true then

    (* INVARIANT: Must have another non-revoked key
       remaining after this revocation. Check that there
       exists a key different from revoke_pk. *)
    get registered_keys(=actor, remaining_pk) in
    if remaining_pk <> revoke_pk then
      (* Check remaining is not revoked *)
      get revoked_keys(=actor, =remaining_pk) in
        (* That remaining key is also revoked;
           last key — block *)
        event ActorHasSingleKey(actor);
        event LastKeyRevocationAttempt(actor, revoke_pk);
        event LastKeyRevocationBlocked(actor, revoke_pk);
        out(c, (actor, revoke_pk, false))
      else
        (* At least one non-revoked key remains *)
        event ActorHasMultipleKeys(actor);
        event RevocationAuthorized(
          actor, revoke_pk, auth_pk
        );
        insert revoked_keys(actor, revoke_pk);
        event KeyRevoked(actor, revoke_pk);
        out(c, (actor, revoke_pk, true))
    else
      (* Only found same key — single key *)
      event ActorHasSingleKey(actor);
      event LastKeyRevocationAttempt(actor, revoke_pk);
      event LastKeyRevocationBlocked(actor, revoke_pk);
      out(c, (actor, revoke_pk, false))
  ).

(* HONEST ACTOR WITH SINGLE KEY *)

let HonestActorSingleKey(actor: actor_id, sk: secret_key) =
  let actor_pk = pk(sk) in
  insert registered_keys(actor, actor_pk);

  (* Try to revoke own only key (should fail) *)
  let msg = RevokeKeyMsg(actor, actor_pk) in
  let sig = sign(msg, sk) in
  out(c, (actor, actor_pk, actor_pk, sig)).

(* HONEST ACTOR WITH TWO KEYS *)

let HonestActorTwoKeys(actor: actor_id, sk1: secret_key, sk2: secret_key) =
  let pk1 = pk(sk1) in
  let pk2 = pk(sk2) in
  insert registered_keys(actor, pk1);
  insert registered_keys(actor, pk2);

  (* Revoke second key using first key (should succeed) *)
  let msg = RevokeKeyMsg(actor, pk2) in
  let sig = sign(msg, sk1) in
  out(c, (actor, pk2, pk1, sig)).

(* HONEST ACTOR ATTEMPTS SELF-REVOCATION *)

let HonestActorSelfRevocation(actor: actor_id, sk1: secret_key, sk2: secret_key) =
  let pk1 = pk(sk1) in
  let pk2 = pk(sk2) in

  (* Try to revoke key using itself (should fail even with multiple keys) *)
  let msg = RevokeKeyMsg(actor, pk1) in
  let sig = sign(msg, sk1) in  (* Signing with same key being revoked *)
  out(c, (actor, pk1, pk1, sig)).

(* HONEST ACTOR WITH THREE KEYS (N-key generalization) *)

let HonestActorThreeKeys(
  actor: actor_id,
  sk1: secret_key, sk2: secret_key, sk3: secret_key
) =
  let pk1 = pk(sk1) in
  let pk2 = pk(sk2) in
  let pk3 = pk(sk3) in
  insert registered_keys(actor, pk1);
  insert registered_keys(actor, pk2);
  insert registered_keys(actor, pk3);

  (* Revoke pk3 using pk1 — should succeed *)
  let msg = RevokeKeyMsg(actor, pk3) in
  let sig = sign(msg, sk1) in
  out(c, (actor, pk3, pk1, sig)).

(* MAIN PROCESS *)

process
  (* Actor with single key *)
  new single_key_actor: actor_id;
  new single_sk: secret_key;
  let single_pk = pk(single_sk) in

  (* Actor with two keys *)
  new multi_key_actor: actor_id;
  new multi_sk1: secret_key;
  new multi_sk2: secret_key;
  let multi_pk1 = pk(multi_sk1) in
  let multi_pk2 = pk(multi_sk2) in

  (* Actor with three keys *)
  new triple_key_actor: actor_id;
  new triple_sk1: secret_key;
  new triple_sk2: secret_key;
  new triple_sk3: secret_key;

  (* Attacker *)
  new attacker_sk: secret_key;
  let attacker_pk = pk(attacker_sk) in
  out(c, attacker_sk);
  out(c, attacker_pk);

  (* Public information *)
  out(c, single_key_actor);
  out(c, single_pk);
  out(c, multi_key_actor);
  out(c, multi_pk1);
  out(c, multi_pk2);
  out(c, triple_key_actor);

  (
    (* Unified PKD process *)
    !PKD_ProcessRevokeKey |

    (* Honest actor scenarios *)
    HonestActorSingleKey(single_key_actor, single_sk) |
    HonestActorTwoKeys(multi_key_actor, multi_sk1, multi_sk2) |
    HonestActorSelfRevocation(
      multi_key_actor, multi_sk1, multi_sk2
    ) |
    HonestActorThreeKeys(
      triple_key_actor, triple_sk1, triple_sk2, triple_sk3
    )
  )
