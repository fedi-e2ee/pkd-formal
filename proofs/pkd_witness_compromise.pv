(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#witness-co-signing *)
(*# At least one witness MUST validate the transparency log. *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#cosigning-a-merkle-root *)
(*# Cosignature uses PAE with domain separation: fedi-e2ee-v1:cosignature *)

(*
  This model verifies security properties when a registered
  witness is compromised (secret key leaked). With n=3
  witnesses and quorum=2:
  - One compromised witness cannot forge quorum alone
  - Compromised witness + honest witness reaches quorum
    but still requires valid root (demonstrates risk)
  - Split-view detection still works with 1 compromised
  - Quorum without compromised witness is safe
*)

(* TYPE DECLARATIONS *)

type pkd_id.
type witness_id.
type public_key.
type secret_key.
type signature.
type merkle_root.
type timestamp.
type hostname.

(* CHANNELS *)

free c: channel.

(* CONSTANTS *)

const COSIGN_CONTEXT: bitstring.
const PAE_KEY_CONTEXT: bitstring.
const PAE_KEY_TIME: bitstring.
const PAE_KEY_HOSTNAME: bitstring.
const PAE_KEY_ROOT: bitstring.

(* CRYPTOGRAPHIC FUNCTIONS *)

fun pk(secret_key): public_key.
fun sign(bitstring, secret_key): signature.
reduc forall m: bitstring, sk: secret_key;
  verify_sig(m, sign(m, sk), pk(sk)) = true.

fun cosign_pae(
  bitstring, bitstring,
  bitstring, timestamp,
  bitstring, hostname,
  bitstring, merkle_root
): bitstring [data].

(* TABLES *)

table witness_keys(witness_id, public_key).
table cosignatures(witness_id, merkle_root, timestamp).
table pkd_roots(pkd_id, merkle_root, timestamp).
table pkd_hostnames(pkd_id, hostname).

(* EVENTS *)

event CosignatureAccepted(
  witness_id, merkle_root, hostname).
event WitnessVerified(witness_id, public_key).
event HostnameValidated(hostname).
event QuorumReached(merkle_root, hostname).
event QuorumWithoutCompromised(merkle_root, hostname).
event CompromisedWitnessUsed(
  witness_id, merkle_root).
event SplitViewDetected(
  pkd_id, merkle_root, merkle_root).
event HonestQuorumReached(merkle_root, hostname).
event FakeRootQuorumBlocked(merkle_root).

(* SECURITY QUERIES *)

(* --- Query 1: Quorum Without Compromised Witness ---
   Two honest witnesses can still reach quorum. *)
query root: merkle_root, host: hostname;
  event(QuorumWithoutCompromised(root, host)) ==> true.

(* --- Query 2: Quorum Does Not Require All Witnesses ---
   Expected: FALSE. This demonstrates that quorum (2-of-3)
   does NOT require every registered witness to cosign.
   The universally quantified wid means "for ALL witnesses,
   quorum implies cosignature" which is correctly false
   because only 2 of 3 witnesses are needed. This proves
   the compromised witness is not required for quorum. *)
query root: merkle_root, host: hostname,
      wid: witness_id;
  event(QuorumReached(root, host)) ==>
    event(CosignatureAccepted(wid, root, host)).

(* --- Query 3: PKD Root Validation Prevents Fake Cosigs ---
   Even with a compromised witness, the PKD's root validation
   check (get pkd_roots) prevents cosignatures for non-existent
   roots. Split view detection cannot trigger because only
   valid roots are accepted. This is a POSITIVE security result:
   the root validation is effective. *)
query pkd: pkd_id, r1: merkle_root, r2: merkle_root;
  event(SplitViewDetected(pkd, r1, r2)).

(* --- Query 4: Honest Witness Key Secrecy ---
   Honest witness secret keys remain secret. *)
free honest_witness1_sk: secret_key [private].
free honest_witness2_sk: secret_key [private].
query attacker(honest_witness1_sk).
query attacker(honest_witness2_sk).

(* --- Query 6: Compromised Witness Cosign Reachability *)
query wid: witness_id, root: merkle_root;
  event(CompromisedWitnessUsed(wid, root)) ==> true.

(* PKD COSIGNATURE VERIFICATION *)

let PKD_VerifyCosignature(
  own_id: pkd_id, own_host: hostname
) =
  in(c, (wid: witness_id, root: merkle_root,
         ts: timestamp, host: hostname,
         wpk: public_key, sig: signature));

  get witness_keys(=wid, =wpk) in
  event WitnessVerified(wid, wpk);

  if host = own_host then
  event HostnameValidated(host);

  get pkd_roots(=own_id, =root, root_ts) in

  let payload = cosign_pae(
    PAE_KEY_CONTEXT, COSIGN_CONTEXT,
    PAE_KEY_TIME, ts,
    PAE_KEY_HOSTNAME, host,
    PAE_KEY_ROOT, root
  ) in
  if verify_sig(payload, sig, wpk) = true then

  insert cosignatures(wid, root, ts);
  event CosignatureAccepted(wid, root, host);
  out(c, (wid, root, true)).

(* CLIENT QUORUM CHECK (2-of-3) *)

let Client_CheckQuorum(
  own_host: hostname,
  compromised_wid: witness_id
) =
  in(c, root: merkle_root);

  get cosignatures(wid1, =root, ts1) in
  get cosignatures(wid2, =root, ts2) in
  get witness_keys(=wid1, wpk1) in
  get witness_keys(=wid2, wpk2) in

  if wpk1 <> wpk2 then
    event QuorumReached(root, own_host);

    (* Check if quorum excludes compromised witness *)
    if wid1 <> compromised_wid then
      if wid2 <> compromised_wid then
        event QuorumWithoutCompromised(root, own_host);
        event HonestQuorumReached(root, own_host);
        out(c, (root, true)).

(* HONEST WITNESS COSIGNING *)

let Witness_Cosign(
  wid: witness_id, wsk: secret_key,
  pkd_host: hostname
) =
  let wpk = pk(wsk) in
  in(c, (root: merkle_root, ts: timestamp));

  let payload = cosign_pae(
    PAE_KEY_CONTEXT, COSIGN_CONTEXT,
    PAE_KEY_TIME, ts,
    PAE_KEY_HOSTNAME, pkd_host,
    PAE_KEY_ROOT, root
  ) in
  let sig = sign(payload, wsk) in

  out(c, (wid, root, ts, pkd_host, wpk, sig)).

(* COMPROMISED WITNESS: attacker has secret key *)

let CompromisedWitness_Cosign(
  wid: witness_id, wsk: secret_key,
  target_host: hostname
) =
  let wpk = pk(wsk) in

  (* Attacker can cosign any root *)
  in(c, (fake_root: merkle_root, ts: timestamp));

  let payload = cosign_pae(
    PAE_KEY_CONTEXT, COSIGN_CONTEXT,
    PAE_KEY_TIME, ts,
    PAE_KEY_HOSTNAME, target_host,
    PAE_KEY_ROOT, fake_root
  ) in
  let sig = sign(payload, wsk) in

  event CompromisedWitnessUsed(wid, fake_root);
  out(c, (wid, fake_root, ts, target_host, wpk, sig)).

(* SPLIT VIEW DETECTION *)

let Client_DetectSplitView(pkd: pkd_id) =
  get cosignatures(wid1, root1, ts1) in
  get cosignatures(wid2, root2, ts2) in
  if root1 <> root2 then
    event SplitViewDetected(pkd, root1, root2).

(* MAIN PROCESS *)

process
  new pkd1_id: pkd_id;
  new pkd1_host: hostname;
  insert pkd_hostnames(pkd1_id, pkd1_host);

  (* Honest witness 1 *)
  new witness1_id: witness_id;
  new witness1_sk: secret_key;
  let witness1_pk = pk(witness1_sk) in
  insert witness_keys(witness1_id, witness1_pk);

  (* Honest witness 2 *)
  new witness2_id: witness_id;
  new witness2_sk: secret_key;
  let witness2_pk = pk(witness2_sk) in
  insert witness_keys(witness2_id, witness2_pk);

  (* Compromised witness 3: attacker has secret key *)
  new witness3_id: witness_id;
  new witness3_sk: secret_key;
  let witness3_pk = pk(witness3_sk) in
  insert witness_keys(witness3_id, witness3_pk);
  (* Leak compromised witness key *)
  out(c, witness3_sk);

  (* Publish valid root *)
  new root1: merkle_root;
  new ts1: timestamp;
  insert pkd_roots(pkd1_id, root1, ts1);

  (* Public info *)
  out(c, pkd1_id);
  out(c, pkd1_host);
  out(c, witness1_id);
  out(c, witness1_pk);
  out(c, witness2_id);
  out(c, witness2_pk);
  out(c, witness3_id);
  out(c, witness3_pk);
  out(c, root1);

  (
    !PKD_VerifyCosignature(pkd1_id, pkd1_host) |
    !Client_CheckQuorum(pkd1_host, witness3_id) |
    !Client_DetectSplitView(pkd1_id) |

    (* Honest witnesses *)
    !Witness_Cosign(
      witness1_id, witness1_sk, pkd1_host) |
    !Witness_Cosign(
      witness2_id, witness2_sk, pkd1_host) |

    (* Compromised witness (attacker controls) *)
    !CompromisedWitness_Cosign(
      witness3_id, witness3_sk, pkd1_host)
  )
