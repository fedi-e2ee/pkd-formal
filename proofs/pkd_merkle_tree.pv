(*= https://www.rfc-editor.org/rfc/rfc9162.txt#section-2.1 *)
(*# Merkle Hash Trees: A Merkle tree is a binary hash tree where each *)
(*# node's hash is derived from the hashes of its child nodes. *)

(*= https://www.rfc-editor.org/rfc/rfc9162.txt#section-2.1.1 *)
(*# Definition: MTH({d(0)}) = HASH(0x00 || d(0)) for single-entry trees. *)
(*# The 0x00 prefix ensures domain separation for leaf nodes. *)

(*= https://www.rfc-editor.org/rfc/rfc9162.txt#section-2.1.1 *)
(*# Definition: MTH(D[n]) = HASH(0x01 || MTH(D[0:k]) || MTH(D[k:n])) *)
(*# The 0x01 prefix ensures domain separation for internal nodes. *)

(* TYPE DECLARATIONS *)

type hash.                     (* Hash values (32 bytes for SHA-256) *)
type leaf_data.                (* Data stored in leaves *)

(* CHANNELS *)

free c: channel.               (* Public network channel *)
free private_c: channel [private].  (* Trusted channel for honest operations *)

(* CRYPTOGRAPHIC FUNCTIONS *)

(* --- Hash Functions (Domain-separated per RFC 9162) --- *)

(* Leaf hash: H(0x00 || leaf_data) *)
fun hash_leaf(leaf_data): hash.

(* Node hash: H(0x01 || left || right) *)
fun hash_node(hash, hash): hash.

(* Hash functions are modeled as constructors (implicitly injective) in ProVerif.
   This captures collision resistance in the symbolic model:
   - hash_leaf(d1) = hash_leaf(d2) implies d1 = d2
   - hash_node(l1,r1) = hash_node(l2,r2) implies l1=l2 and r1=r2
   - hash_leaf(x) â‰  hash_node(a, b) for any x, a, b (domain separation) *)

(* EVENTS FOR SECURITY PROPERTIES *)

(* Core events for tracking honest operations *)
event LeafInTree(leaf_data, hash).          (* Leaf is part of tree with this root *)
event RootPublished(hash).                  (* PKD published this root *)
event InclusionVerified(leaf_data, hash).   (* Client verified inclusion *)
event ConsistencyVerified(hash, hash).      (* Auditor verified consistency *)

(* SECURITY QUERIES *)

(* --- Query 1: Root Binding ---
   A published root uniquely determines tree contents.
   If inclusion is verified for leaf in root, and root was published,
   then leaf was actually added to that tree. *)
query leaf: leaf_data, root: hash;
  event(InclusionVerified(leaf, root)) ==> event(LeafInTree(leaf, root)).

(* --- Query 2: Append-Only Consistency ---
   If consistency is verified between old and new root, both are valid roots. *)
query old_r: hash, new_r: hash;
  event(ConsistencyVerified(old_r, new_r)) ==>
    (event(RootPublished(old_r)) && event(RootPublished(new_r))).

(* --- Query 3: Leaf Secrecy ---
   Private leaf data remains secret even if hash is published. *)
free secret_leaf: leaf_data [private].
query attacker(secret_leaf).

(* --- Query 4: Domain Separation ---
   Ensure leaf and node hashes cannot collide.
   This is inherent in the model since hash_leaf and hash_node
   are distinct constructors, but we verify the effect. *)
free test_leaf: leaf_data [private].
query attacker(test_leaf).

(* SINGLE-LEAF TREE *)

let PKD_SingleLeaf =
  in(private_c, leaf1: leaf_data);
  let h1 = hash_leaf(leaf1) in
  let root = h1 in
  (* Record that this leaf is in the tree with this root *)
  event LeafInTree(leaf1, root);
  event RootPublished(root);
  (* Output the root and proof components *)
  out(c, root);
  (* For single leaf, inclusion proof is empty: just verify hash *)
  in(c, query_leaf: leaf_data);
  if hash_leaf(query_leaf) = root then
    event InclusionVerified(query_leaf, root).

(* TWO-LEAF TREE *)

let PKD_TwoLeaf =
  in(private_c, (leaf1: leaf_data, leaf2: leaf_data));
  let h1 = hash_leaf(leaf1) in
  let h2 = hash_leaf(leaf2) in
  let old_root = h1 in
  let new_root = hash_node(h1, h2) in

  (* Record membership *)
  event LeafInTree(leaf1, old_root);
  event RootPublished(old_root);
  event LeafInTree(leaf1, new_root);
  event LeafInTree(leaf2, new_root);
  event RootPublished(new_root);

  (* Output roots *)
  out(c, (old_root, new_root));

  (* Handle inclusion verification for left leaf (index 0) *)
  (
    in(c, query_leaf: leaf_data);
    let query_hash = hash_leaf(query_leaf) in
    (* Proof for left leaf: provide right sibling *)
    if hash_node(query_hash, h2) = new_root then
      event InclusionVerified(query_leaf, new_root)
  ) |
  (* Handle inclusion verification for right leaf (index 1) *)
  (
    in(c, query_leaf: leaf_data);
    let query_hash = hash_leaf(query_leaf) in
    (* Proof for right leaf: provide left sibling *)
    if hash_node(h1, query_hash) = new_root then
      event InclusionVerified(query_leaf, new_root)
  ) |
  (* Handle consistency verification *)
  (
    (* Verify old_root is prefix of new_root *)
    if hash_node(old_root, h2) = new_root then
      event ConsistencyVerified(old_root, new_root)
  ).

(* FOUR-LEAF TREE (demonstrates larger tree structure) *)

let PKD_FourLeaf =
  in(private_c, (leaf1: leaf_data, leaf2: leaf_data, leaf3: leaf_data, leaf4: leaf_data));
  let h1 = hash_leaf(leaf1) in
  let h2 = hash_leaf(leaf2) in
  let h3 = hash_leaf(leaf3) in
  let h4 = hash_leaf(leaf4) in

  (* Build tree structure:
           root
          /    \
        h12    h34
        / \    / \
       h1 h2  h3 h4
  *)
  let h12 = hash_node(h1, h2) in
  let h34 = hash_node(h3, h4) in
  let root = hash_node(h12, h34) in

  (* Record membership *)
  event LeafInTree(leaf1, root);
  event LeafInTree(leaf2, root);
  event LeafInTree(leaf3, root);
  event LeafInTree(leaf4, root);
  event RootPublished(root);

  out(c, root);

  (* Verify inclusion for leaf1: path is [h2, h34] *)
  (
    in(c, query_leaf: leaf_data);
    let qh = hash_leaf(query_leaf) in
    let computed_h12 = hash_node(qh, h2) in
    let computed_root = hash_node(computed_h12, h34) in
    if computed_root = root then
      event InclusionVerified(query_leaf, root)
  ) |
  (* Verify inclusion for leaf2: path is [h1, h34] *)
  (
    in(c, query_leaf: leaf_data);
    let qh = hash_leaf(query_leaf) in
    let computed_h12 = hash_node(h1, qh) in
    let computed_root = hash_node(computed_h12, h34) in
    if computed_root = root then
      event InclusionVerified(query_leaf, root)
  ) |
  (* Verify inclusion for leaf3: path is [h4, h12] *)
  (
    in(c, query_leaf: leaf_data);
    let qh = hash_leaf(query_leaf) in
    let computed_h34 = hash_node(qh, h4) in
    let computed_root = hash_node(h12, computed_h34) in
    if computed_root = root then
      event InclusionVerified(query_leaf, root)
  ) |
  (* Verify inclusion for leaf4: path is [h3, h12] *)
  (
    in(c, query_leaf: leaf_data);
    let qh = hash_leaf(query_leaf) in
    let computed_h34 = hash_node(h3, qh) in
    let computed_root = hash_node(h12, computed_h34) in
    if computed_root = root then
      event InclusionVerified(query_leaf, root)
  ).

(* MAIN PROCESS *)

process
  new leaf_a: leaf_data;
  new leaf_b: leaf_data;
  new leaf_c: leaf_data;
  new leaf_d: leaf_data;
  (
    (* Provide leaves to tree processes *)
    out(private_c, leaf_a) |
    out(private_c, (leaf_a, leaf_b)) |
    out(private_c, (leaf_a, leaf_b, leaf_c, leaf_d)) |

    (* Run tree processes *)
    !PKD_SingleLeaf |
    !PKD_TwoLeaf |
    !PKD_FourLeaf |

    (* Attacker can query with any leaf they have *)
    !in(c, any_root: hash); out(c, any_root)
  )
