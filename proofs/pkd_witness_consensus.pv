(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#witness-co-signing *)
(*# Witnesses are independent entities that monitor the PKD and co-sign the Merkle tree root. *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#witness-co-signing *)
(*# At least one witness MUST validate the transparency log. *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#cosigning-a-merkle-root *)
(*# Cosignature uses PAE with domain separation: fedi-e2ee-v1:cosignature *)

(* TYPE DECLARATIONS *)

type pkd_id.
type witness_id.
type public_key.
type secret_key.
type signature.
type merkle_root.
type timestamp.
type hostname.

(* CHANNELS *)

free c: channel.
free witness_channel: channel.

(* CONSTANTS *)

const COSIGN_CONTEXT: bitstring.   (* "fedi-e2ee-v1:cosignature" *)

(* PAE key-name constants matching spec's 8-piece structure:
   "!pkd-context" : "fedi-e2ee-v1:cosignature"
   "current-time" : <timestamp>
   "hostname"     : <hostname>
   "merkle-root"  : <merkle-root> *)
const PAE_KEY_CONTEXT: bitstring.  (* "!pkd-context" *)
const PAE_KEY_TIME: bitstring.     (* "current-time" *)
const PAE_KEY_HOSTNAME: bitstring. (* "hostname" *)
const PAE_KEY_ROOT: bitstring.     (* "merkle-root" *)

(* CRYPTOGRAPHIC FUNCTIONS *)

fun pk(secret_key): public_key.
fun sign(bitstring, secret_key): signature.
reduc forall m: bitstring, sk: secret_key;
  verify_sig(m, sign(m, sk), pk(sk)) = true.

(* 8-piece PAE: 4 key-value pairs *)
fun cosign_pae(
  bitstring, bitstring,
  bitstring, timestamp,
  bitstring, hostname,
  bitstring, merkle_root
): bitstring [data].

(* TABLES *)

table witness_keys(witness_id, public_key).
table cosignatures(witness_id, merkle_root, timestamp).
table pkd_roots(pkd_id, merkle_root, timestamp).
table pkd_hostnames(pkd_id, hostname).

(* EVENTS *)

event CosignatureReceived(witness_id, merkle_root, hostname).
event CosignatureAccepted(witness_id, merkle_root, hostname).
event CosignatureRejected(witness_id, merkle_root).
event WitnessVerified(witness_id, public_key).
event WitnessUnknown(witness_id).
event HostnameValidated(hostname).
event QuorumReached(merkle_root, hostname).
event SplitViewDetected(pkd_id, merkle_root, merkle_root).
event WitnessValidatedLog(witness_id, merkle_root).
event PKDPublishedRoot(pkd_id, merkle_root).

(* SECURITY QUERIES *)

query wid: witness_id, root: merkle_root,
      host: hostname, wpk: public_key;
  event(CosignatureAccepted(wid, root, host)) ==>
    event(WitnessVerified(wid, wpk)).

query wid: witness_id, root: merkle_root,
      host: hostname;
  event(CosignatureAccepted(wid, root, host)) ==>
    event(HostnameValidated(host)).

query pkd: pkd_id, root1: merkle_root,
      root2: merkle_root;
  event(SplitViewDetected(pkd, root1, root2)).

free honest_witness_sk: secret_key [private].
query attacker(honest_witness_sk).

query root: merkle_root, host: hostname;
  event(QuorumReached(root, host)) ==> true.

(* PKD COSIGNATURE VERIFICATION *)

let PKD_VerifyCosignature(
  own_id: pkd_id, own_host: hostname
) =
  in(c, (wid: witness_id, root: merkle_root,
         ts: timestamp, host: hostname,
         wpk: public_key, sig: signature));

  event CosignatureReceived(wid, root, host);

  get witness_keys(=wid, =wpk) in
  event WitnessVerified(wid, wpk);

  if host = own_host then
  event HostnameValidated(host);

  get pkd_roots(=own_id, =root, root_ts) in

  let payload = cosign_pae(
    PAE_KEY_CONTEXT, COSIGN_CONTEXT,
    PAE_KEY_TIME, ts,
    PAE_KEY_HOSTNAME, host,
    PAE_KEY_ROOT, root
  ) in
  if verify_sig(payload, sig, wpk) = true then

  insert cosignatures(wid, root, ts);
  event CosignatureAccepted(wid, root, host);
  out(c, (wid, root, true))

  else
    event CosignatureRejected(wid, root)
  else
    event CosignatureRejected(wid, root).

(* CLIENT QUORUM CHECK *)

let Client_CheckQuorum(own_host: hostname) =
  in(c, (root: merkle_root));

  get cosignatures(wid1, =root, ts1) in
  get cosignatures(wid2, =root, ts2) in
  get witness_keys(=wid1, wpk1) in
  get witness_keys(=wid2, wpk2) in

  if wpk1 <> wpk2 then
    event QuorumReached(root, own_host);
    out(c, (root, true)).

(* WITNESS COSIGNING *)

let Witness_Cosign(
  wid: witness_id, wsk: secret_key,
  pkd_host: hostname
) =
  let wpk = pk(wsk) in
  in(c, (root: merkle_root, ts: timestamp));

  event WitnessValidatedLog(wid, root);

  let payload = cosign_pae(
    PAE_KEY_CONTEXT, COSIGN_CONTEXT,
    PAE_KEY_TIME, ts,
    PAE_KEY_HOSTNAME, pkd_host,
    PAE_KEY_ROOT, root
  ) in
  let sig = sign(payload, wsk) in

  out(c, (wid, root, ts, pkd_host, wpk, sig)).

(* SPLIT VIEW DETECTION *)

let Client_DetectSplitView(pkd: pkd_id) =
  get cosignatures(wid1, root1, ts1) in
  get cosignatures(wid2, root2, ts2) in
  if root1 <> root2 then
    event SplitViewDetected(pkd, root1, root2).

(* ATTACKER *)

let AttackerFakeWitness(target_host: hostname) =
  new fake_wid: witness_id;
  new fake_sk: secret_key;
  let fake_pk = pk(fake_sk) in
  new fake_root: merkle_root;
  new ts: timestamp;

  let payload = cosign_pae(
    PAE_KEY_CONTEXT, COSIGN_CONTEXT,
    PAE_KEY_TIME, ts,
    PAE_KEY_HOSTNAME, target_host,
    PAE_KEY_ROOT, fake_root
  ) in
  let sig = sign(payload, fake_sk) in
  out(c, (fake_wid, fake_root, ts, target_host,
          fake_pk, sig)).

let AttackerSplitView(pkd: pkd_id) =
  new root_a: merkle_root;
  new root_b: merkle_root;
  new ts: timestamp;
  out(c, (root_a, ts));
  out(c, (root_b, ts)).

(* MAIN PROCESS *)

process
  new pkd1_id: pkd_id;
  new pkd1_host: hostname;
  insert pkd_hostnames(pkd1_id, pkd1_host);

  new witness1_id: witness_id;
  new witness1_sk: secret_key;
  let witness1_pk = pk(witness1_sk) in
  insert witness_keys(witness1_id, witness1_pk);

  new witness2_id: witness_id;
  new witness2_sk: secret_key;
  let witness2_pk = pk(witness2_sk) in
  insert witness_keys(witness2_id, witness2_pk);

  new root1: merkle_root;
  new ts1: timestamp;
  insert pkd_roots(pkd1_id, root1, ts1);
  event PKDPublishedRoot(pkd1_id, root1);

  out(c, pkd1_id);
  out(c, pkd1_host);
  out(c, witness1_id);
  out(c, witness1_pk);
  out(c, witness2_id);
  out(c, witness2_pk);
  out(c, root1);

  (
    !PKD_VerifyCosignature(pkd1_id, pkd1_host) |
    !Client_CheckQuorum(pkd1_host) |
    !Client_DetectSplitView(pkd1_id) |
    !Witness_Cosign(witness1_id, witness1_sk, pkd1_host) |
    !Witness_Cosign(witness2_id, witness2_sk, pkd1_host) |
    !AttackerFakeWitness(pkd1_host) |
    !AttackerSplitView(pkd1_id)
  )
