(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#totp *)
(*# Every Fediverse instance may enroll a secret key for use with TOTP (RFC 6238). *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#totp-configuration *)
(*# Time window size: 30 seconds. Hash function: SHA-512. OTP length: 8 digits. *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#totp-verification *)
(*# Each TOTP code MUST be accepted for verification only once. *)

(*= https://raw.githubusercontent.com/fedi-e2ee/public-key-directory-specification/refs/heads/main/Specification.md#totp-verification *)
(*# Accepted time windows: current (t), t-1, t-2 per RFC 6238 section 5.2. *)

(* TYPE DECLARATIONS *)

type server_id.
type actor_id.
type public_key.
type secret_key.
type signature.
type totp_key.                 (* 256-bit TOTP shared secret *)
type totp_code.                (* 8-digit TOTP code *)
type time_window.              (* 30-second time window *)
type message.

(* CHANNELS *)

free c: channel.
free pkd_internal: channel [private].

(* CRYPTOGRAPHIC FUNCTIONS *)

fun pk(secret_key): public_key.
fun sign(message, secret_key): signature.
reduc forall m: message, sk: secret_key;
  verify(m, sign(m, sk), pk(sk)) = true.

fun totp_generate(totp_key, time_window): totp_code.
reduc forall s: totp_key, tw: time_window;
  totp_verify(totp_generate(s, tw), s, tw) = true.

type hpke_public.
type hpke_privkey.
type hpke_ciphertext.

fun hpke_pk(hpke_privkey): hpke_public.
fun hpke_seal(hpke_public, totp_key): hpke_ciphertext.
reduc forall sk: hpke_privkey, m: totp_key;
  hpke_open(sk, hpke_seal(hpke_pk(sk), m)) = m.

fun EnrollMsg(actor_id, server_id): message.
fun DisenrollMsg(actor_id, server_id): message.
fun RotateMsg(actor_id, server_id): message.

(* Spec: accepts t, t-1, t-2 *)
fun prev_window(time_window): time_window.

(* TABLES *)

table enrolled_totp(server_id, totp_key).
table used_codes(server_id, totp_code, time_window).
table registered_keys(actor_id, public_key).
table actor_servers(actor_id, server_id).

(* EVENTS *)

event TOTPKeyGenerated(server_id, totp_key).
event TOTPEnrolled(server_id, totp_key).
event TOTPDisenrolled(server_id).
event TOTPRotated(server_id, totp_key, totp_key).
event TOTPVerifiedOnce(
  server_id, totp_code, time_window).
event TOTPReplayRejected(server_id, totp_code).
event TOTPCodeValid(server_id, totp_code).
event TOTPCodeInvalid(server_id, totp_code).
event EnrollSignatureVerified(actor_id, public_key).
event EnrollDuplicateRejected(server_id).

(* SECURITY QUERIES *)

free honest_totp_key: totp_key [private].
query attacker(honest_totp_key).

query server: server_id, tkey: totp_key,
      actor: actor_id, auth_pk: public_key;
  event(TOTPEnrolled(server, tkey)) ==>
    event(EnrollSignatureVerified(actor, auth_pk)).

query server: server_id, code: totp_code,
      tw: time_window;
  event(TOTPCodeValid(server, code)) ==>
    event(TOTPVerifiedOnce(server, code, tw)).

query server: server_id, old_key: totp_key,
      new_key: totp_key, code: totp_code;
  event(TOTPRotated(server, old_key, new_key)) ==>
    event(TOTPCodeValid(server, code)).

query server: server_id;
  event(EnrollDuplicateRejected(server)) ==> true.

(* PKD TOTP ENROLLMENT *)

let PKD_ProcessEnroll(pkd_hpke_sk: hpke_privkey) =
  in(c, (actor: actor_id, server: server_id,
         auth_pk: public_key, sig: signature,
         encrypted_key: hpke_ciphertext,
         otp_current: totp_code,
         otp_previous: totp_code,
         tw_current: time_window));

  let msg = EnrollMsg(actor, server) in

  get registered_keys(=actor, =auth_pk) in
  get actor_servers(=actor, =server) in
  if verify(msg, sig, auth_pk) = true then
  event EnrollSignatureVerified(actor, auth_pk);

  get enrolled_totp(=server, existing_key) in
    event EnrollDuplicateRejected(server)
  else
    let tkey = hpke_open(
      pkd_hpke_sk, encrypted_key) in

    let tw_prev = prev_window(tw_current) in
    if totp_verify(
      otp_current, tkey, tw_current) = true then
    if totp_verify(
      otp_previous, tkey, tw_prev) = true then

    insert enrolled_totp(server, tkey);
    event TOTPEnrolled(server, tkey);
    out(c, (server, true)).

(* PKD TOTP VERIFICATION
   Spec: accepts windows t, t-1, t-2 per RFC 6238 ยง5.2 *)

let PKD_VerifyTOTP =
  in(c, (server: server_id, code: totp_code,
         tw: time_window));

  get enrolled_totp(=server, tkey) in

  get used_codes(=server, =code, used_tw) in
    event TOTPReplayRejected(server, code)
  else
    (* Try current window (t) *)
    if totp_verify(code, tkey, tw) = true then
      insert used_codes(server, code, tw);
      event TOTPVerifiedOnce(server, code, tw);
      event TOTPCodeValid(server, code);
      out(c, (server, true))
    else
      (* Try t-1 *)
      let tw1 = prev_window(tw) in
      if totp_verify(code, tkey, tw1) = true then
        insert used_codes(server, code, tw1);
        event TOTPVerifiedOnce(server, code, tw1);
        event TOTPCodeValid(server, code);
        out(c, (server, true))
      else
        (* Try t-2 per RFC 6238 ยง5.2 *)
        let tw2 = prev_window(tw1) in
        if totp_verify(code, tkey, tw2) = true then
          insert used_codes(server, code, tw2);
          event TOTPVerifiedOnce(server, code, tw2);
          event TOTPCodeValid(server, code);
          out(c, (server, true))
        else
          event TOTPCodeInvalid(server, code).

(* PKD TOTP DISENROLLMENT *)

let PKD_ProcessDisenroll(pkd_hpke_sk: hpke_privkey) =
  in(c, (actor: actor_id, server: server_id,
         auth_pk: public_key, sig: signature,
         otp: totp_code, tw: time_window));

  let msg = DisenrollMsg(actor, server) in

  get registered_keys(=actor, =auth_pk) in
  get actor_servers(=actor, =server) in
  if verify(msg, sig, auth_pk) = true then

  get enrolled_totp(=server, tkey) in
  if totp_verify(otp, tkey, tw) = true then

  event TOTPDisenrolled(server);
  out(c, (server, true)).

(* PKD TOTP ROTATION *)

let PKD_ProcessRotate(pkd_hpke_sk: hpke_privkey) =
  in(c, (actor: actor_id, server: server_id,
         auth_pk: public_key, sig: signature,
         new_encrypted_key: hpke_ciphertext,
         new_otp_current: totp_code,
         new_otp_previous: totp_code,
         old_otp: totp_code,
         tw: time_window));

  let msg = RotateMsg(actor, server) in

  get registered_keys(=actor, =auth_pk) in
  get actor_servers(=actor, =server) in
  if verify(msg, sig, auth_pk) = true then

  get enrolled_totp(=server, old_key) in
  if totp_verify(old_otp, old_key, tw) = true then
  event TOTPCodeValid(server, old_otp);

  let new_key = hpke_open(
    pkd_hpke_sk, new_encrypted_key) in

  let tw_prev = prev_window(tw) in
  if totp_verify(
    new_otp_current, new_key, tw) = true then
  if totp_verify(
    new_otp_previous, new_key, tw_prev) = true then

  insert enrolled_totp(server, new_key);
  event TOTPRotated(server, old_key, new_key);
  out(c, (server, true)).

(* HONEST PROCESSES *)

let HonestAdmin(
  actor: actor_id, actor_sk: secret_key,
  server: server_id, tkey: totp_key,
  pkd_hpke_pk: hpke_public
) =
  let actor_pk = pk(actor_sk) in
  insert registered_keys(actor, actor_pk);
  insert actor_servers(actor, server);

  let encrypted = hpke_seal(pkd_hpke_pk, tkey) in

  new tw: time_window;
  let tw_prev = prev_window(tw) in
  let otp_current = totp_generate(tkey, tw) in
  let otp_previous = totp_generate(tkey, tw_prev) in

  let msg = EnrollMsg(actor, server) in
  let sig = sign(msg, actor_sk) in

  event TOTPKeyGenerated(server, tkey);
  out(c, (actor, server, actor_pk, sig,
          encrypted, otp_current, otp_previous, tw)).

(* ATTACKER *)

let AttackerReplayTOTP(server: server_id) =
  in(c, (captured_code: totp_code, tw: time_window));
  out(c, (server, captured_code, tw)).

let AttackerBruteForceTOTP(server: server_id) =
  new fake_key: totp_key;
  new tw: time_window;
  let fake_code = totp_generate(fake_key, tw) in
  out(c, (server, fake_code, tw)).

(* MAIN PROCESS *)

process
  new pkd_hpke_sk: hpke_privkey;
  let pkd_hpke_pk = hpke_pk(pkd_hpke_sk) in

  new honest_actor: actor_id;
  new honest_sk: secret_key;
  new honest_server: server_id;

  new attacker_sk: secret_key;
  let attacker_pk = pk(attacker_sk) in
  out(c, attacker_sk);
  out(c, attacker_pk);

  out(c, pkd_hpke_pk);
  out(c, honest_actor);
  out(c, pk(honest_sk));
  out(c, honest_server);

  (
    !PKD_ProcessEnroll(pkd_hpke_sk) |
    !PKD_VerifyTOTP |
    !PKD_ProcessDisenroll(pkd_hpke_sk) |
    !PKD_ProcessRotate(pkd_hpke_sk) |
    HonestAdmin(honest_actor, honest_sk, honest_server,
                honest_totp_key, pkd_hpke_pk) |
    !AttackerReplayTOTP(honest_server) |
    !AttackerBruteForceTOTP(honest_server)
  )
